/*
* ---------------------------------------------------------
* Copyright(C) Microsoft Corporation. All rights reserved.
* ---------------------------------------------------------
*
* ---------------------------------------------------------
* Generated file, DO NOT EDIT
* ---------------------------------------------------------
*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
// Licensed under the MIT license.  See LICENSE file in the project root for full license information.
/// <reference path="../node/node.d.ts"/>
/// <reference path="../q/Q.d.ts"/>
var Q = require('q');
var basem = require('./ClientApiBases');
var FileContainerInterfaces = require("./interfaces/FileContainerInterfaces");
var VSSInterfaces = require("./interfaces/common/VSSInterfaces");
var FileContainerApiBase = (function (_super) {
    __extends(FileContainerApiBase, _super);
    function FileContainerApiBase(baseUrl, handlers) {
        _super.call(this, baseUrl, handlers, 'node-FileContainer-api');
    }
    /**
     * Creates the specified items in in the referenced container.
     *
     * @param {VSSInterfaces.VssJsonCollectionWrapperV<FileContainerInterfaces.FileContainerItem[]>} items
     * @param {number} containerId
     * @param {string} scope - A guid representing the scope of the container. This is often the project id.
     * @param onResult callback function with the resulting FileContainerInterfaces.FileContainerItem[]
     */
    FileContainerApiBase.prototype.createItems = function (items, containerId, scope, onResult) {
        var _this = this;
        var routeValues = {
            containerId: containerId
        };
        var queryValues = {
            scope: scope,
        };
        this.vsoClient.getVersioningData("3.0-preview.3", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: VSSInterfaces.TypeInfo.VssJsonCollectionWrapperV, responseTypeMetadata: FileContainerInterfaces.TypeInfo.FileContainerItem, responseIsCollection: true };
            _this.restClient.create(url, apiVersion, items, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Deletes the specified items in a container.
     *
     * @param {number} containerId - Container Id.
     * @param {string} itemPath - Path to delete.
     * @param {string} scope - A guid representing the scope of the container. This is often the project id.
     * @param onResult callback function
     */
    FileContainerApiBase.prototype.deleteItem = function (containerId, itemPath, scope, onResult) {
        var _this = this;
        var routeValues = {
            containerId: containerId
        };
        var queryValues = {
            itemPath: itemPath,
            scope: scope,
        };
        this.vsoClient.getVersioningData("3.0-preview.3", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.delete(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode);
        });
    };
    /**
     * Gets containers filtered by a comma separated list of artifact uris within the same scope, if not specified returns all containers
     *
     * @param {string} scope - A guid representing the scope of the container. This is often the project id.
     * @param {string} artifactUris
     * @param onResult callback function with the resulting FileContainerInterfaces.FileContainer[]
     */
    FileContainerApiBase.prototype.getContainers = function (scope, artifactUris, onResult) {
        var _this = this;
        var routeValues = {};
        var queryValues = {
            scope: scope,
            artifactUris: artifactUris,
        };
        this.vsoClient.getVersioningData("3.0-preview.3", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: FileContainerInterfaces.TypeInfo.FileContainer, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * @param {number} containerId
     * @param {string} scope
     * @param {string} itemPath
     * @param {boolean} metadata
     * @param {string} format
     * @param {string} downloadFileName
     * @param {boolean} includeDownloadTickets
     * @param {boolean} isShallow
     * @param onResult callback function with the resulting FileContainerInterfaces.FileContainerItem[]
     */
    FileContainerApiBase.prototype.getItems = function (containerId, scope, itemPath, metadata, format, downloadFileName, includeDownloadTickets, isShallow, onResult) {
        var _this = this;
        var routeValues = {
            containerId: containerId
        };
        var queryValues = {
            scope: scope,
            itemPath: itemPath,
            metadata: metadata,
            '$format': format,
            downloadFileName: downloadFileName,
            includeDownloadTickets: includeDownloadTickets,
            isShallow: isShallow,
        };
        this.vsoClient.getVersioningData("3.0-preview.3", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: FileContainerInterfaces.TypeInfo.FileContainerItem, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Allow browsing of file ,the contentDisposition is inline and Content-Type is determined by FileExtension
     *
     * @param {number} container
     * @param {string} itemPath - The path to the item of interest
     * @param onResult callback function with the resulting FileContainerInterfaces.FileContainerItem[]
     */
    FileContainerApiBase.prototype.browseItems = function (container, itemPath, onResult) {
        var _this = this;
        var routeValues = {
            container: container
        };
        var queryValues = {
            itemPath: itemPath,
        };
        this.vsoClient.getVersioningData("3.0-preview.3", "Container", "e71a64ac-b2b5-4230-a4c0-dad657cf97e2", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: FileContainerInterfaces.TypeInfo.FileContainerItem, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    return FileContainerApiBase;
}(basem.ClientApiBase));
exports.FileContainerApiBase = FileContainerApiBase;
var QFileContainerApiBase = (function (_super) {
    __extends(QFileContainerApiBase, _super);
    function QFileContainerApiBase(baseUrl, handlers, api) {
        _super.call(this, baseUrl, handlers, api);
    }
    /**
    * Creates the specified items in in the referenced container.
    *
    * @param {VSSInterfaces.VssJsonCollectionWrapperV<FileContainerInterfaces.FileContainerItem[]>} items
    * @param {number} containerId
    * @param {string} scope - A guid representing the scope of the container. This is often the project id.
    */
    QFileContainerApiBase.prototype.createItems = function (items, containerId, scope) {
        var deferred = Q.defer();
        this.api.createItems(items, containerId, scope, function (err, statusCode, Container) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Container);
            }
        });
        return deferred.promise;
    };
    /**
    * Deletes the specified items in a container.
    *
    * @param {number} containerId - Container Id.
    * @param {string} itemPath - Path to delete.
    * @param {string} scope - A guid representing the scope of the container. This is often the project id.
    */
    QFileContainerApiBase.prototype.deleteItem = function (containerId, itemPath, scope) {
        var deferred = Q.defer();
        this.api.deleteItem(containerId, itemPath, scope, function (err, statusCode) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(null);
            }
        });
        return deferred.promise;
    };
    /**
    * Gets containers filtered by a comma separated list of artifact uris within the same scope, if not specified returns all containers
    *
    * @param {string} scope - A guid representing the scope of the container. This is often the project id.
    * @param {string} artifactUris
    */
    QFileContainerApiBase.prototype.getContainers = function (scope, artifactUris) {
        var deferred = Q.defer();
        this.api.getContainers(scope, artifactUris, function (err, statusCode, Containers) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Containers);
            }
        });
        return deferred.promise;
    };
    /**
    * @param {number} containerId
    * @param {string} scope
    * @param {string} itemPath
    * @param {boolean} metadata
    * @param {string} format
    * @param {string} downloadFileName
    * @param {boolean} includeDownloadTickets
    * @param {boolean} isShallow
    */
    QFileContainerApiBase.prototype.getItems = function (containerId, scope, itemPath, metadata, format, downloadFileName, includeDownloadTickets, isShallow) {
        var deferred = Q.defer();
        this.api.getItems(containerId, scope, itemPath, metadata, format, downloadFileName, includeDownloadTickets, isShallow, function (err, statusCode, Containers) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Containers);
            }
        });
        return deferred.promise;
    };
    /**
    * Allow browsing of file ,the contentDisposition is inline and Content-Type is determined by FileExtension
    *
    * @param {number} container
    * @param {string} itemPath - The path to the item of interest
    */
    QFileContainerApiBase.prototype.browseItems = function (container, itemPath) {
        var deferred = Q.defer();
        this.api.browseItems(container, itemPath, function (err, statusCode, Containers) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Containers);
            }
        });
        return deferred.promise;
    };
    return QFileContainerApiBase;
}(basem.QClientApiBase));
exports.QFileContainerApiBase = QFileContainerApiBase;
