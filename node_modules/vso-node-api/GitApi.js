/*
* ---------------------------------------------------------
* Copyright(C) Microsoft Corporation. All rights reserved.
* ---------------------------------------------------------
*
* ---------------------------------------------------------
* Generated file, DO NOT EDIT
* ---------------------------------------------------------
*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
// Licensed under the MIT license.  See LICENSE file in the project root for full license information.
/// <reference path="../node/node.d.ts"/>
/// <reference path="../q/Q.d.ts"/>
var Q = require('q');
var basem = require('./ClientApiBases');
var GitInterfaces = require("./interfaces/GitInterfaces");
var VSSInterfaces = require("./interfaces/common/VSSInterfaces");
var GitApi = (function (_super) {
    __extends(GitApi, _super);
    function GitApi(baseUrl, handlers) {
        _super.call(this, baseUrl, handlers, 'node-Git-api');
    }
    /**
     * Gets a single blob.
     *
     * @param {string} repositoryId
     * @param {string} sha1
     * @param {string} project - Project ID or project name
     * @param {boolean} download
     * @param {string} fileName
     * @param onResult callback function with the resulting GitInterfaces.GitBlobRef
     */
    GitApi.prototype.getBlob = function (repositoryId, sha1, project, download, fileName, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            sha1: sha1
        };
        var queryValues = {
            download: download,
            fileName: fileName,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitBlobRef, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Gets a single blob.
     *
     * @param {string} repositoryId
     * @param {string} sha1
     * @param {string} project - Project ID or project name
     * @param {boolean} download
     * @param {string} fileName
     * @param onResult callback function with the resulting ArrayBuffer
     */
    GitApi.prototype.getBlobContent = function (repositoryId, sha1, project, download, fileName, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            sha1: sha1
        };
        var queryValues = {
            download: download,
            fileName: fileName,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.httpClient.getStream(url, apiVersion, "application/octet-stream", onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Gets one or more blobs in a zip file download.
     *
     * @param {string[]} blobIds
     * @param {string} repositoryId
     * @param {string} project - Project ID or project name
     * @param {string} filename
     * @param onResult callback function with the resulting ArrayBuffer
     */
    GitApi.prototype.getBlobsZip = function (blobIds, repositoryId, project, filename, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            filename: filename,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.httpClient.getStream(url, apiVersion, "application/zip", onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Gets a single blob.
     *
     * @param {string} repositoryId
     * @param {string} sha1
     * @param {string} project - Project ID or project name
     * @param {boolean} download
     * @param {string} fileName
     * @param onResult callback function with the resulting ArrayBuffer
     */
    GitApi.prototype.getBlobZip = function (repositoryId, sha1, project, download, fileName, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            sha1: sha1
        };
        var queryValues = {
            download: download,
            fileName: fileName,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.httpClient.getStream(url, apiVersion, "application/zip", onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Retrieve statistics about a single branch.
     *
     * @param {string} repositoryId - Friendly name or guid of repository
     * @param {string} name - Name of the branch
     * @param {string} project - Project ID or project name
     * @param {GitInterfaces.GitVersionDescriptor} baseVersionDescriptor
     * @param onResult callback function with the resulting GitInterfaces.GitBranchStats
     */
    GitApi.prototype.getBranch = function (repositoryId, name, project, baseVersionDescriptor, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            name: name,
            baseVersionDescriptor: baseVersionDescriptor,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "d5b216de-d8d5-4d32-ae76-51df755b16d3", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitBranchStats, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Retrieve statistics about all branches within a repository.
     *
     * @param {string} repositoryId - Friendly name or guid of repository
     * @param {string} project - Project ID or project name
     * @param {GitInterfaces.GitVersionDescriptor} baseVersionDescriptor
     * @param onResult callback function with the resulting GitInterfaces.GitBranchStats[]
     */
    GitApi.prototype.getBranches = function (repositoryId, project, baseVersionDescriptor, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            baseVersionDescriptor: baseVersionDescriptor,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "d5b216de-d8d5-4d32-ae76-51df755b16d3", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitBranchStats, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Retrieve changes for a particular commit.
     *
     * @param {string} commitId - The id of the commit.
     * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
     * @param {string} project - Project ID or project name
     * @param {number} top - The maximum number of changes to return.
     * @param {number} skip - The number of changes to skip.
     * @param onResult callback function with the resulting GitInterfaces.GitCommitChanges
     */
    GitApi.prototype.getChanges = function (commitId, repositoryId, project, top, skip, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            commitId: commitId,
            repositoryId: repositoryId
        };
        var queryValues = {
            top: top,
            skip: skip,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "5bf884f5-3e07-42e9-afb8-1b872267bf16", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitCommitChanges, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Retrieve a particular commit.
     *
     * @param {string} commitId - The id of the commit.
     * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
     * @param {string} project - Project ID or project name
     * @param {number} changeCount - The number of changes to include in the result.
     * @param onResult callback function with the resulting GitInterfaces.GitCommit
     */
    GitApi.prototype.getCommit = function (commitId, repositoryId, project, changeCount, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            commitId: commitId,
            repositoryId: repositoryId
        };
        var queryValues = {
            changeCount: changeCount,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "c2570c3b-5b3f-41b8-98bf-5407bfde8d58", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitCommit, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Retrieve git commits for a project
     *
     * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
     * @param {GitInterfaces.GitQueryCommitsCriteria} searchCriteria
     * @param {string} project - Project ID or project name
     * @param {number} skip
     * @param {number} top
     * @param onResult callback function with the resulting GitInterfaces.GitCommitRef[]
     */
    GitApi.prototype.getCommits = function (repositoryId, searchCriteria, project, skip, top, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            searchCriteria: searchCriteria,
            '$skip': skip,
            '$top': top,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "c2570c3b-5b3f-41b8-98bf-5407bfde8d58", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitCommitRef, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Retrieve a list of commits associated with a particular push.
     *
     * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
     * @param {number} pushId - The id of the push.
     * @param {string} project - Project ID or project name
     * @param {number} top - The maximum number of commits to return ("get the top x commits").
     * @param {number} skip - The number of commits to skip.
     * @param {boolean} includeLinks
     * @param onResult callback function with the resulting GitInterfaces.GitCommitRef[]
     */
    GitApi.prototype.getPushCommits = function (repositoryId, pushId, project, top, skip, includeLinks, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            pushId: pushId,
            top: top,
            skip: skip,
            includeLinks: includeLinks,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "c2570c3b-5b3f-41b8-98bf-5407bfde8d58", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitCommitRef, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Retrieve git commits for a project
     *
     * @param {GitInterfaces.GitQueryCommitsCriteria} searchCriteria - Search options
     * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
     * @param {string} project - Project ID or project name
     * @param {number} skip
     * @param {number} top
     * @param onResult callback function with the resulting GitInterfaces.GitCommitRef[]
     */
    GitApi.prototype.getCommitsBatch = function (searchCriteria, repositoryId, project, skip, top, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            '$skip': skip,
            '$top': top,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "6400dfb2-0bcb-462b-b992-5a57f8f1416c", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitQueryCommitsCriteria, responseTypeMetadata: GitInterfaces.TypeInfo.GitCommitRef, responseIsCollection: true };
            _this.restClient.create(url, apiVersion, searchCriteria, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Retrieve deleted git repositories.
     *
     * @param {string} project - Project ID or project name
     * @param onResult callback function with the resulting GitInterfaces.GitDeletedRepository[]
     */
    GitApi.prototype.getDeletedRepositories = function (project, onResult) {
        var _this = this;
        var routeValues = {
            project: project
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "2b6869c4-cb25-42b5-b7a3-0d3e6be0a11a", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitDeletedRepository, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
     *
     * @param {string} repositoryId
     * @param {string} path
     * @param {string} project - Project ID or project name
     * @param {string} scopePath
     * @param {GitInterfaces.VersionControlRecursionType} recursionLevel
     * @param {boolean} includeContentMetadata
     * @param {boolean} latestProcessedChange
     * @param {boolean} download
     * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor
     * @param onResult callback function with the resulting GitInterfaces.GitItem
     */
    GitApi.prototype.getItem = function (repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            path: path,
            scopePath: scopePath,
            recursionLevel: recursionLevel,
            includeContentMetadata: includeContentMetadata,
            latestProcessedChange: latestProcessedChange,
            download: download,
            versionDescriptor: versionDescriptor,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitItem, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
     *
     * @param {string} repositoryId
     * @param {string} path
     * @param {string} project - Project ID or project name
     * @param {string} scopePath
     * @param {GitInterfaces.VersionControlRecursionType} recursionLevel
     * @param {boolean} includeContentMetadata
     * @param {boolean} latestProcessedChange
     * @param {boolean} download
     * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor
     * @param onResult callback function with the resulting ArrayBuffer
     */
    GitApi.prototype.getItemContent = function (repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            path: path,
            scopePath: scopePath,
            recursionLevel: recursionLevel,
            includeContentMetadata: includeContentMetadata,
            latestProcessedChange: latestProcessedChange,
            download: download,
            versionDescriptor: versionDescriptor,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.httpClient.getStream(url, apiVersion, "application/octet-stream", onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Get Item Metadata and/or Content for a collection of items. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
     *
     * @param {string} repositoryId
     * @param {string} project - Project ID or project name
     * @param {string} scopePath
     * @param {GitInterfaces.VersionControlRecursionType} recursionLevel
     * @param {boolean} includeContentMetadata
     * @param {boolean} latestProcessedChange
     * @param {boolean} download
     * @param {boolean} includeLinks
     * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor
     * @param onResult callback function with the resulting GitInterfaces.GitItem[]
     */
    GitApi.prototype.getItems = function (repositoryId, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, includeLinks, versionDescriptor, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            scopePath: scopePath,
            recursionLevel: recursionLevel,
            includeContentMetadata: includeContentMetadata,
            latestProcessedChange: latestProcessedChange,
            download: download,
            includeLinks: includeLinks,
            versionDescriptor: versionDescriptor,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitItem, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
     *
     * @param {string} repositoryId
     * @param {string} path
     * @param {string} project - Project ID or project name
     * @param {string} scopePath
     * @param {GitInterfaces.VersionControlRecursionType} recursionLevel
     * @param {boolean} includeContentMetadata
     * @param {boolean} latestProcessedChange
     * @param {boolean} download
     * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor
     * @param onResult callback function with the resulting string
     */
    GitApi.prototype.getItemText = function (repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            path: path,
            scopePath: scopePath,
            recursionLevel: recursionLevel,
            includeContentMetadata: includeContentMetadata,
            latestProcessedChange: latestProcessedChange,
            download: download,
            versionDescriptor: versionDescriptor,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.httpClient.getStream(url, apiVersion, "text/plain", onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
     *
     * @param {string} repositoryId
     * @param {string} path
     * @param {string} project - Project ID or project name
     * @param {string} scopePath
     * @param {GitInterfaces.VersionControlRecursionType} recursionLevel
     * @param {boolean} includeContentMetadata
     * @param {boolean} latestProcessedChange
     * @param {boolean} download
     * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor
     * @param onResult callback function with the resulting ArrayBuffer
     */
    GitApi.prototype.getItemZip = function (repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            path: path,
            scopePath: scopePath,
            recursionLevel: recursionLevel,
            includeContentMetadata: includeContentMetadata,
            latestProcessedChange: latestProcessedChange,
            download: download,
            versionDescriptor: versionDescriptor,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.httpClient.getStream(url, apiVersion, "application/zip", onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Post for retrieving a creating a batch out of a set of items in a repo / project given a list of paths or a long path
     *
     * @param {GitInterfaces.GitItemRequestData} requestData
     * @param {string} repositoryId
     * @param {string} project - Project ID or project name
     * @param onResult callback function with the resulting GitInterfaces.GitItem[][]
     */
    GitApi.prototype.getItemsBatch = function (requestData, repositoryId, project, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "630fd2e4-fb88-4f85-ad21-13f3fd1fbca9", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitItemRequestData, responseTypeMetadata: GitInterfaces.TypeInfo.GitItem, responseIsCollection: true };
            _this.restClient.create(url, apiVersion, requestData, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Retrieve pull request's commits
     *
     * @param {string} repositoryId
     * @param {number} pullRequestId
     * @param {string} project - Project ID or project name
     * @param onResult callback function with the resulting GitInterfaces.GitCommitRef[]
     */
    GitApi.prototype.getPullRequestCommits = function (repositoryId, pullRequestId, project, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "52823034-34a8-4576-922c-8d8b77e9e4c4", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitCommitRef, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Adds a reviewer to a git pull request
     *
     * @param {GitInterfaces.IdentityRefWithVote} reviewer
     * @param {string} repositoryId
     * @param {number} pullRequestId
     * @param {string} reviewerId
     * @param {string} project - Project ID or project name
     * @param onResult callback function with the resulting GitInterfaces.IdentityRefWithVote
     */
    GitApi.prototype.createPullRequestReviewer = function (reviewer, repositoryId, pullRequestId, reviewerId, project, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            reviewerId: reviewerId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.IdentityRefWithVote, responseTypeMetadata: GitInterfaces.TypeInfo.IdentityRefWithVote, responseIsCollection: false };
            _this.restClient.replace(url, apiVersion, reviewer, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Adds reviewers to a git pull request
     *
     * @param {VSSInterfaces.IdentityRef[]} reviewers
     * @param {string} repositoryId
     * @param {number} pullRequestId
     * @param {string} project - Project ID or project name
     * @param onResult callback function with the resulting GitInterfaces.IdentityRefWithVote[]
     */
    GitApi.prototype.createPullRequestReviewers = function (reviewers, repositoryId, pullRequestId, project, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: VSSInterfaces.TypeInfo.IdentityRef, responseTypeMetadata: GitInterfaces.TypeInfo.IdentityRefWithVote, responseIsCollection: true };
            _this.restClient.create(url, apiVersion, reviewers, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Adds reviewers to a git pull request
     *
     * @param {string} repositoryId
     * @param {number} pullRequestId
     * @param {string} reviewerId
     * @param {string} project - Project ID or project name
     * @param onResult callback function
     */
    GitApi.prototype.deletePullRequestReviewer = function (repositoryId, pullRequestId, reviewerId, project, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            reviewerId: reviewerId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.delete(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode);
        });
    };
    /**
     * Retrieve a reviewer from a pull request
     *
     * @param {string} repositoryId
     * @param {number} pullRequestId
     * @param {string} reviewerId
     * @param {string} project - Project ID or project name
     * @param onResult callback function with the resulting GitInterfaces.IdentityRefWithVote
     */
    GitApi.prototype.getPullRequestReviewer = function (repositoryId, pullRequestId, reviewerId, project, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId,
            reviewerId: reviewerId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.IdentityRefWithVote, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Retrieve a pull request reviewers
     *
     * @param {string} repositoryId
     * @param {number} pullRequestId
     * @param {string} project - Project ID or project name
     * @param onResult callback function with the resulting GitInterfaces.IdentityRefWithVote[]
     */
    GitApi.prototype.getPullRequestReviewers = function (repositoryId, pullRequestId, project, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.IdentityRefWithVote, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Query pull requests by project
     *
     * @param {string} project - Project ID or project name
     * @param {GitInterfaces.GitPullRequestSearchCriteria} searchCriteria
     * @param {number} maxCommentLength
     * @param {number} skip
     * @param {number} top
     * @param onResult callback function with the resulting GitInterfaces.GitPullRequest[]
     */
    GitApi.prototype.getPullRequestsByProject = function (project, searchCriteria, maxCommentLength, skip, top, onResult) {
        var _this = this;
        var routeValues = {
            project: project
        };
        var queryValues = {
            searchCriteria: searchCriteria,
            maxCommentLength: maxCommentLength,
            '$skip': skip,
            '$top': top,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "a5d28130-9cd2-40fa-9f08-902e7daa9efb", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequest, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Create a git pull request
     *
     * @param {GitInterfaces.GitPullRequest} gitPullRequestToCreate
     * @param {string} repositoryId
     * @param {string} project - Project ID or project name
     * @param onResult callback function with the resulting GitInterfaces.GitPullRequest
     */
    GitApi.prototype.createPullRequest = function (gitPullRequestToCreate, repositoryId, project, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitPullRequest, responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequest, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, gitPullRequestToCreate, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Retrieve a pull request
     *
     * @param {string} repositoryId
     * @param {number} pullRequestId
     * @param {string} project - Project ID or project name
     * @param {number} maxCommentLength
     * @param {number} skip
     * @param {number} top
     * @param {boolean} includeCommits
     * @param onResult callback function with the resulting GitInterfaces.GitPullRequest
     */
    GitApi.prototype.getPullRequest = function (repositoryId, pullRequestId, project, maxCommentLength, skip, top, includeCommits, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        var queryValues = {
            maxCommentLength: maxCommentLength,
            '$skip': skip,
            '$top': top,
            includeCommits: includeCommits,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequest, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Query for pull requests
     *
     * @param {string} repositoryId
     * @param {GitInterfaces.GitPullRequestSearchCriteria} searchCriteria
     * @param {string} project - Project ID or project name
     * @param {number} maxCommentLength
     * @param {number} skip
     * @param {number} top
     * @param onResult callback function with the resulting GitInterfaces.GitPullRequest[]
     */
    GitApi.prototype.getPullRequests = function (repositoryId, searchCriteria, project, maxCommentLength, skip, top, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            searchCriteria: searchCriteria,
            maxCommentLength: maxCommentLength,
            '$skip': skip,
            '$top': top,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequest, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Updates a pull request
     *
     * @param {GitInterfaces.GitPullRequest} gitPullRequestToUpdate
     * @param {string} repositoryId
     * @param {number} pullRequestId
     * @param {string} project - Project ID or project name
     * @param onResult callback function with the resulting GitInterfaces.GitPullRequest
     */
    GitApi.prototype.updatePullRequest = function (gitPullRequestToUpdate, repositoryId, pullRequestId, project, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitPullRequest, responseTypeMetadata: GitInterfaces.TypeInfo.GitPullRequest, responseIsCollection: false };
            _this.restClient.update(url, apiVersion, gitPullRequestToUpdate, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Retrieve a pull request work items
     *
     * @param {string} repositoryId
     * @param {number} pullRequestId
     * @param {string} project - Project ID or project name
     * @param {number} commitsTop
     * @param {number} commitsSkip
     * @param onResult callback function with the resulting GitInterfaces.AssociatedWorkItem[]
     */
    GitApi.prototype.getPullRequestWorkItems = function (repositoryId, pullRequestId, project, commitsTop, commitsSkip, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pullRequestId: pullRequestId
        };
        var queryValues = {
            commitsTop: commitsTop,
            commitsSkip: commitsSkip,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "0a637fcc-5370-4ce8-b0e8-98091f5f9482", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.AssociatedWorkItem, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Push changes to the repository.
     *
     * @param {GitInterfaces.GitPush} push
     * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, a project-scoped route must be used.
     * @param {string} project - Project ID or project name
     * @param onResult callback function with the resulting GitInterfaces.GitPush
     */
    GitApi.prototype.createPush = function (push, repositoryId, project, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.0-preview.2", "git", "ea98d07b-3c87-4971-8ede-a613694ffb55", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitPush, responseTypeMetadata: GitInterfaces.TypeInfo.GitPush, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, push, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Retrieve a particular push.
     *
     * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
     * @param {number} pushId - The id of the push.
     * @param {string} project - Project ID or project name
     * @param {number} includeCommits - The number of commits to include in the result.
     * @param {boolean} includeRefUpdates
     * @param onResult callback function with the resulting GitInterfaces.GitPush
     */
    GitApi.prototype.getPush = function (repositoryId, pushId, project, includeCommits, includeRefUpdates, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            pushId: pushId
        };
        var queryValues = {
            includeCommits: includeCommits,
            includeRefUpdates: includeRefUpdates,
        };
        this.vsoClient.getVersioningData("3.0-preview.2", "git", "ea98d07b-3c87-4971-8ede-a613694ffb55", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPush, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Retrieves pushes associated with the specified repository.
     *
     * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
     * @param {string} project - Project ID or project name
     * @param {number} skip
     * @param {number} top
     * @param {GitInterfaces.GitPushSearchCriteria} searchCriteria
     * @param onResult callback function with the resulting GitInterfaces.GitPush[]
     */
    GitApi.prototype.getPushes = function (repositoryId, project, skip, top, searchCriteria, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            '$skip': skip,
            '$top': top,
            searchCriteria: searchCriteria,
        };
        this.vsoClient.getVersioningData("3.0-preview.2", "git", "ea98d07b-3c87-4971-8ede-a613694ffb55", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitPush, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Queries the provided repository for its refs and returns them.
     *
     * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
     * @param {string} project - Project ID or project name
     * @param {string} filter - [optional] A filter to apply to the refs.
     * @param {boolean} includeLinks - [optional] Specifies if referenceLinks should be included in the result. default is false.
     * @param onResult callback function with the resulting GitInterfaces.GitRef[]
     */
    GitApi.prototype.getRefs = function (repositoryId, project, filter, includeLinks, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            filter: filter,
            includeLinks: includeLinks,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "2d874a60-a811-4f62-9c9f-963a6ea0a55b", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitRef, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Creates or updates refs with the given information
     *
     * @param {GitInterfaces.GitRefUpdate[]} refUpdates - List of ref updates to attempt to perform
     * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
     * @param {string} project - Project ID or project name
     * @param {string} projectId - The id of the project.
     * @param onResult callback function with the resulting GitInterfaces.GitRefUpdateResult[]
     */
    GitApi.prototype.updateRefs = function (refUpdates, repositoryId, project, projectId, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        var queryValues = {
            projectId: projectId,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "2d874a60-a811-4f62-9c9f-963a6ea0a55b", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitRefUpdate, responseTypeMetadata: GitInterfaces.TypeInfo.GitRefUpdateResult, responseIsCollection: true };
            _this.restClient.create(url, apiVersion, refUpdates, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Create a git repository
     *
     * @param {GitInterfaces.GitRepository} gitRepositoryToCreate
     * @param {string} project - Project ID or project name
     * @param onResult callback function with the resulting GitInterfaces.GitRepository
     */
    GitApi.prototype.createRepository = function (gitRepositoryToCreate, project, onResult) {
        var _this = this;
        var routeValues = {
            project: project
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitRepository, responseTypeMetadata: GitInterfaces.TypeInfo.GitRepository, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, gitRepositoryToCreate, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Delete a git repository
     *
     * @param {string} repositoryId
     * @param {string} project - Project ID or project name
     * @param onResult callback function
     */
    GitApi.prototype.deleteRepository = function (repositoryId, project, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.restClient.delete(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode);
        });
    };
    /**
     * Retrieve git repositories.
     *
     * @param {string} project - Project ID or project name
     * @param {boolean} includeLinks
     * @param onResult callback function with the resulting GitInterfaces.GitRepository[]
     */
    GitApi.prototype.getRepositories = function (project, includeLinks, onResult) {
        var _this = this;
        var routeValues = {
            project: project
        };
        var queryValues = {
            includeLinks: includeLinks,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitRepository, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * @param {string} repositoryId
     * @param {string} project - Project ID or project name
     * @param onResult callback function with the resulting GitInterfaces.GitRepository
     */
    GitApi.prototype.getRepository = function (repositoryId, project, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitRepository, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * Updates the Git repository with the single populated change in the specified repository information.
     *
     * @param {GitInterfaces.GitRepository} newRepositoryInfo
     * @param {string} repositoryId
     * @param {string} project - Project ID or project name
     * @param onResult callback function with the resulting GitInterfaces.GitRepository
     */
    GitApi.prototype.updateRepository = function (newRepositoryInfo, repositoryId, project, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitRepository, responseTypeMetadata: GitInterfaces.TypeInfo.GitRepository, responseIsCollection: false };
            _this.restClient.update(url, apiVersion, newRepositoryInfo, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * @param {GitInterfaces.GitStatus} gitCommitStatusToCreate
     * @param {string} commitId
     * @param {string} repositoryId
     * @param {string} project - Project ID or project name
     * @param onResult callback function with the resulting GitInterfaces.GitStatus
     */
    GitApi.prototype.createCommitStatus = function (gitCommitStatusToCreate, commitId, repositoryId, project, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            commitId: commitId,
            repositoryId: repositoryId
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "428dd4fb-fda5-4722-af02-9313b80305da", routeValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { requestTypeMetadata: GitInterfaces.TypeInfo.GitStatus, responseTypeMetadata: GitInterfaces.TypeInfo.GitStatus, responseIsCollection: false };
            _this.restClient.create(url, apiVersion, gitCommitStatusToCreate, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * @param {string} commitId
     * @param {string} repositoryId
     * @param {string} project - Project ID or project name
     * @param {number} top
     * @param {number} skip
     * @param onResult callback function with the resulting GitInterfaces.GitStatus[]
     */
    GitApi.prototype.getStatuses = function (commitId, repositoryId, project, top, skip, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            commitId: commitId,
            repositoryId: repositoryId
        };
        var queryValues = {
            top: top,
            skip: skip,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "428dd4fb-fda5-4722-af02-9313b80305da", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitStatus, responseIsCollection: true };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * @param {string} repositoryId
     * @param {string} sha1
     * @param {string} project - Project ID or project name
     * @param {string} projectId
     * @param {boolean} recursive
     * @param {string} fileName
     * @param onResult callback function with the resulting GitInterfaces.GitTreeRef
     */
    GitApi.prototype.getTree = function (repositoryId, sha1, project, projectId, recursive, fileName, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            sha1: sha1
        };
        var queryValues = {
            projectId: projectId,
            recursive: recursive,
            fileName: fileName,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "729f6437-6f92-44ec-8bee-273a7111063c", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseTypeMetadata: GitInterfaces.TypeInfo.GitTreeRef, responseIsCollection: false };
            _this.restClient.getJson(url, apiVersion, null, serializationData, onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    /**
     * @param {string} repositoryId
     * @param {string} sha1
     * @param {string} project - Project ID or project name
     * @param {string} projectId
     * @param {boolean} recursive
     * @param {string} fileName
     * @param onResult callback function with the resulting ArrayBuffer
     */
    GitApi.prototype.getTreeZip = function (repositoryId, sha1, project, projectId, recursive, fileName, onResult) {
        var _this = this;
        var routeValues = {
            project: project,
            repositoryId: repositoryId,
            sha1: sha1
        };
        var queryValues = {
            projectId: projectId,
            recursive: recursive,
            fileName: fileName,
        };
        this.vsoClient.getVersioningData("3.0-preview.1", "git", "729f6437-6f92-44ec-8bee-273a7111063c", routeValues, queryValues)
            .then(function (versioningData) {
            var url = versioningData.requestUrl;
            var apiVersion = versioningData.apiVersion;
            var serializationData = { responseIsCollection: false };
            _this.httpClient.getStream(url, apiVersion, "application/zip", onResult);
        })
            .fail(function (error) {
            onResult(error, error.statusCode, null);
        });
    };
    return GitApi;
}(basem.ClientApiBase));
exports.GitApi = GitApi;
var QGitApi = (function (_super) {
    __extends(QGitApi, _super);
    function QGitApi(baseUrl, handlers) {
        _super.call(this, baseUrl, handlers, GitApi);
    }
    /**
    * Gets a single blob.
    *
    * @param {string} repositoryId
    * @param {string} sha1
    * @param {string} project - Project ID or project name
    * @param {boolean} download
    * @param {string} fileName
    */
    QGitApi.prototype.getBlob = function (repositoryId, sha1, project, download, fileName) {
        var deferred = Q.defer();
        this.api.getBlob(repositoryId, sha1, project, download, fileName, function (err, statusCode, Blob) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Blob);
            }
        });
        return deferred.promise;
    };
    /**
    * Gets a single blob.
    *
    * @param {string} repositoryId
    * @param {string} sha1
    * @param {string} project - Project ID or project name
    * @param {boolean} download
    * @param {string} fileName
    */
    QGitApi.prototype.getBlobContent = function (repositoryId, sha1, project, download, fileName) {
        var deferred = Q.defer();
        this.api.getBlobContent(repositoryId, sha1, project, download, fileName, function (err, statusCode, Blob) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Blob);
            }
        });
        return deferred.promise;
    };
    /**
    * Gets one or more blobs in a zip file download.
    *
    * @param {string[]} blobIds
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    * @param {string} filename
    */
    QGitApi.prototype.getBlobsZip = function (blobIds, repositoryId, project, filename) {
        var deferred = Q.defer();
        this.api.getBlobsZip(blobIds, repositoryId, project, filename, function (err, statusCode, Blob) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Blob);
            }
        });
        return deferred.promise;
    };
    /**
    * Gets a single blob.
    *
    * @param {string} repositoryId
    * @param {string} sha1
    * @param {string} project - Project ID or project name
    * @param {boolean} download
    * @param {string} fileName
    */
    QGitApi.prototype.getBlobZip = function (repositoryId, sha1, project, download, fileName) {
        var deferred = Q.defer();
        this.api.getBlobZip(repositoryId, sha1, project, download, fileName, function (err, statusCode, Blob) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Blob);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieve statistics about a single branch.
    *
    * @param {string} repositoryId - Friendly name or guid of repository
    * @param {string} name - Name of the branch
    * @param {string} project - Project ID or project name
    * @param {GitInterfaces.GitVersionDescriptor} baseVersionDescriptor
    */
    QGitApi.prototype.getBranch = function (repositoryId, name, project, baseVersionDescriptor) {
        var deferred = Q.defer();
        this.api.getBranch(repositoryId, name, project, baseVersionDescriptor, function (err, statusCode, BranchStat) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(BranchStat);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieve statistics about all branches within a repository.
    *
    * @param {string} repositoryId - Friendly name or guid of repository
    * @param {string} project - Project ID or project name
    * @param {GitInterfaces.GitVersionDescriptor} baseVersionDescriptor
    */
    QGitApi.prototype.getBranches = function (repositoryId, project, baseVersionDescriptor) {
        var deferred = Q.defer();
        this.api.getBranches(repositoryId, project, baseVersionDescriptor, function (err, statusCode, BranchStats) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(BranchStats);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieve changes for a particular commit.
    *
    * @param {string} commitId - The id of the commit.
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {string} project - Project ID or project name
    * @param {number} top - The maximum number of changes to return.
    * @param {number} skip - The number of changes to skip.
    */
    QGitApi.prototype.getChanges = function (commitId, repositoryId, project, top, skip) {
        var deferred = Q.defer();
        this.api.getChanges(commitId, repositoryId, project, top, skip, function (err, statusCode, Change) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Change);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieve a particular commit.
    *
    * @param {string} commitId - The id of the commit.
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {string} project - Project ID or project name
    * @param {number} changeCount - The number of changes to include in the result.
    */
    QGitApi.prototype.getCommit = function (commitId, repositoryId, project, changeCount) {
        var deferred = Q.defer();
        this.api.getCommit(commitId, repositoryId, project, changeCount, function (err, statusCode, Commit) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Commit);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieve git commits for a project
    *
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {GitInterfaces.GitQueryCommitsCriteria} searchCriteria
    * @param {string} project - Project ID or project name
    * @param {number} skip
    * @param {number} top
    */
    QGitApi.prototype.getCommits = function (repositoryId, searchCriteria, project, skip, top) {
        var deferred = Q.defer();
        this.api.getCommits(repositoryId, searchCriteria, project, skip, top, function (err, statusCode, Commits) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Commits);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieve a list of commits associated with a particular push.
    *
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {number} pushId - The id of the push.
    * @param {string} project - Project ID or project name
    * @param {number} top - The maximum number of commits to return ("get the top x commits").
    * @param {number} skip - The number of commits to skip.
    * @param {boolean} includeLinks
    */
    QGitApi.prototype.getPushCommits = function (repositoryId, pushId, project, top, skip, includeLinks) {
        var deferred = Q.defer();
        this.api.getPushCommits(repositoryId, pushId, project, top, skip, includeLinks, function (err, statusCode, Commits) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Commits);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieve git commits for a project
    *
    * @param {GitInterfaces.GitQueryCommitsCriteria} searchCriteria - Search options
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {string} project - Project ID or project name
    * @param {number} skip
    * @param {number} top
    */
    QGitApi.prototype.getCommitsBatch = function (searchCriteria, repositoryId, project, skip, top) {
        var deferred = Q.defer();
        this.api.getCommitsBatch(searchCriteria, repositoryId, project, skip, top, function (err, statusCode, CommitsBatch) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(CommitsBatch);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieve deleted git repositories.
    *
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.getDeletedRepositories = function (project) {
        var deferred = Q.defer();
        this.api.getDeletedRepositories(project, function (err, statusCode, DeletedRepositories) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(DeletedRepositories);
            }
        });
        return deferred.promise;
    };
    /**
    * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
    *
    * @param {string} repositoryId
    * @param {string} path
    * @param {string} project - Project ID or project name
    * @param {string} scopePath
    * @param {GitInterfaces.VersionControlRecursionType} recursionLevel
    * @param {boolean} includeContentMetadata
    * @param {boolean} latestProcessedChange
    * @param {boolean} download
    * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor
    */
    QGitApi.prototype.getItem = function (repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor) {
        var deferred = Q.defer();
        this.api.getItem(repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, function (err, statusCode, Item) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Item);
            }
        });
        return deferred.promise;
    };
    /**
    * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
    *
    * @param {string} repositoryId
    * @param {string} path
    * @param {string} project - Project ID or project name
    * @param {string} scopePath
    * @param {GitInterfaces.VersionControlRecursionType} recursionLevel
    * @param {boolean} includeContentMetadata
    * @param {boolean} latestProcessedChange
    * @param {boolean} download
    * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor
    */
    QGitApi.prototype.getItemContent = function (repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor) {
        var deferred = Q.defer();
        this.api.getItemContent(repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, function (err, statusCode, Item) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Item);
            }
        });
        return deferred.promise;
    };
    /**
    * Get Item Metadata and/or Content for a collection of items. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
    *
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    * @param {string} scopePath
    * @param {GitInterfaces.VersionControlRecursionType} recursionLevel
    * @param {boolean} includeContentMetadata
    * @param {boolean} latestProcessedChange
    * @param {boolean} download
    * @param {boolean} includeLinks
    * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor
    */
    QGitApi.prototype.getItems = function (repositoryId, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, includeLinks, versionDescriptor) {
        var deferred = Q.defer();
        this.api.getItems(repositoryId, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, includeLinks, versionDescriptor, function (err, statusCode, Items) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Items);
            }
        });
        return deferred.promise;
    };
    /**
    * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
    *
    * @param {string} repositoryId
    * @param {string} path
    * @param {string} project - Project ID or project name
    * @param {string} scopePath
    * @param {GitInterfaces.VersionControlRecursionType} recursionLevel
    * @param {boolean} includeContentMetadata
    * @param {boolean} latestProcessedChange
    * @param {boolean} download
    * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor
    */
    QGitApi.prototype.getItemText = function (repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor) {
        var deferred = Q.defer();
        this.api.getItemText(repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, function (err, statusCode, Item) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Item);
            }
        });
        return deferred.promise;
    };
    /**
    * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
    *
    * @param {string} repositoryId
    * @param {string} path
    * @param {string} project - Project ID or project name
    * @param {string} scopePath
    * @param {GitInterfaces.VersionControlRecursionType} recursionLevel
    * @param {boolean} includeContentMetadata
    * @param {boolean} latestProcessedChange
    * @param {boolean} download
    * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor
    */
    QGitApi.prototype.getItemZip = function (repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor) {
        var deferred = Q.defer();
        this.api.getItemZip(repositoryId, path, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, function (err, statusCode, Item) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Item);
            }
        });
        return deferred.promise;
    };
    /**
    * Post for retrieving a creating a batch out of a set of items in a repo / project given a list of paths or a long path
    *
    * @param {GitInterfaces.GitItemRequestData} requestData
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.getItemsBatch = function (requestData, repositoryId, project) {
        var deferred = Q.defer();
        this.api.getItemsBatch(requestData, repositoryId, project, function (err, statusCode, ItemsBatch) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(ItemsBatch);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieve pull request's commits
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.getPullRequestCommits = function (repositoryId, pullRequestId, project) {
        var deferred = Q.defer();
        this.api.getPullRequestCommits(repositoryId, pullRequestId, project, function (err, statusCode, PullRequestCommits) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestCommits);
            }
        });
        return deferred.promise;
    };
    /**
    * Adds a reviewer to a git pull request
    *
    * @param {GitInterfaces.IdentityRefWithVote} reviewer
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} reviewerId
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.createPullRequestReviewer = function (reviewer, repositoryId, pullRequestId, reviewerId, project) {
        var deferred = Q.defer();
        this.api.createPullRequestReviewer(reviewer, repositoryId, pullRequestId, reviewerId, project, function (err, statusCode, PullRequestReviewer) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestReviewer);
            }
        });
        return deferred.promise;
    };
    /**
    * Adds reviewers to a git pull request
    *
    * @param {VSSInterfaces.IdentityRef[]} reviewers
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.createPullRequestReviewers = function (reviewers, repositoryId, pullRequestId, project) {
        var deferred = Q.defer();
        this.api.createPullRequestReviewers(reviewers, repositoryId, pullRequestId, project, function (err, statusCode, PullRequestReviewers) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestReviewers);
            }
        });
        return deferred.promise;
    };
    /**
    * Adds reviewers to a git pull request
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} reviewerId
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.deletePullRequestReviewer = function (repositoryId, pullRequestId, reviewerId, project) {
        var deferred = Q.defer();
        this.api.deletePullRequestReviewer(repositoryId, pullRequestId, reviewerId, project, function (err, statusCode) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(null);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieve a reviewer from a pull request
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} reviewerId
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.getPullRequestReviewer = function (repositoryId, pullRequestId, reviewerId, project) {
        var deferred = Q.defer();
        this.api.getPullRequestReviewer(repositoryId, pullRequestId, reviewerId, project, function (err, statusCode, PullRequestReviewer) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestReviewer);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieve a pull request reviewers
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.getPullRequestReviewers = function (repositoryId, pullRequestId, project) {
        var deferred = Q.defer();
        this.api.getPullRequestReviewers(repositoryId, pullRequestId, project, function (err, statusCode, PullRequestReviewers) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestReviewers);
            }
        });
        return deferred.promise;
    };
    /**
    * Query pull requests by project
    *
    * @param {string} project - Project ID or project name
    * @param {GitInterfaces.GitPullRequestSearchCriteria} searchCriteria
    * @param {number} maxCommentLength
    * @param {number} skip
    * @param {number} top
    */
    QGitApi.prototype.getPullRequestsByProject = function (project, searchCriteria, maxCommentLength, skip, top) {
        var deferred = Q.defer();
        this.api.getPullRequestsByProject(project, searchCriteria, maxCommentLength, skip, top, function (err, statusCode, PullRequests) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequests);
            }
        });
        return deferred.promise;
    };
    /**
    * Create a git pull request
    *
    * @param {GitInterfaces.GitPullRequest} gitPullRequestToCreate
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.createPullRequest = function (gitPullRequestToCreate, repositoryId, project) {
        var deferred = Q.defer();
        this.api.createPullRequest(gitPullRequestToCreate, repositoryId, project, function (err, statusCode, PullRequest) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequest);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieve a pull request
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    * @param {number} maxCommentLength
    * @param {number} skip
    * @param {number} top
    * @param {boolean} includeCommits
    */
    QGitApi.prototype.getPullRequest = function (repositoryId, pullRequestId, project, maxCommentLength, skip, top, includeCommits) {
        var deferred = Q.defer();
        this.api.getPullRequest(repositoryId, pullRequestId, project, maxCommentLength, skip, top, includeCommits, function (err, statusCode, PullRequest) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequest);
            }
        });
        return deferred.promise;
    };
    /**
    * Query for pull requests
    *
    * @param {string} repositoryId
    * @param {GitInterfaces.GitPullRequestSearchCriteria} searchCriteria
    * @param {string} project - Project ID or project name
    * @param {number} maxCommentLength
    * @param {number} skip
    * @param {number} top
    */
    QGitApi.prototype.getPullRequests = function (repositoryId, searchCriteria, project, maxCommentLength, skip, top) {
        var deferred = Q.defer();
        this.api.getPullRequests(repositoryId, searchCriteria, project, maxCommentLength, skip, top, function (err, statusCode, PullRequests) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequests);
            }
        });
        return deferred.promise;
    };
    /**
    * Updates a pull request
    *
    * @param {GitInterfaces.GitPullRequest} gitPullRequestToUpdate
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.updatePullRequest = function (gitPullRequestToUpdate, repositoryId, pullRequestId, project) {
        var deferred = Q.defer();
        this.api.updatePullRequest(gitPullRequestToUpdate, repositoryId, pullRequestId, project, function (err, statusCode, PullRequest) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequest);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieve a pull request work items
    *
    * @param {string} repositoryId
    * @param {number} pullRequestId
    * @param {string} project - Project ID or project name
    * @param {number} commitsTop
    * @param {number} commitsSkip
    */
    QGitApi.prototype.getPullRequestWorkItems = function (repositoryId, pullRequestId, project, commitsTop, commitsSkip) {
        var deferred = Q.defer();
        this.api.getPullRequestWorkItems(repositoryId, pullRequestId, project, commitsTop, commitsSkip, function (err, statusCode, PullRequestWorkItems) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(PullRequestWorkItems);
            }
        });
        return deferred.promise;
    };
    /**
    * Push changes to the repository.
    *
    * @param {GitInterfaces.GitPush} push
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, a project-scoped route must be used.
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.createPush = function (push, repositoryId, project) {
        var deferred = Q.defer();
        this.api.createPush(push, repositoryId, project, function (err, statusCode, pushe) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(pushe);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieve a particular push.
    *
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {number} pushId - The id of the push.
    * @param {string} project - Project ID or project name
    * @param {number} includeCommits - The number of commits to include in the result.
    * @param {boolean} includeRefUpdates
    */
    QGitApi.prototype.getPush = function (repositoryId, pushId, project, includeCommits, includeRefUpdates) {
        var deferred = Q.defer();
        this.api.getPush(repositoryId, pushId, project, includeCommits, includeRefUpdates, function (err, statusCode, pushe) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(pushe);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieves pushes associated with the specified repository.
    *
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {string} project - Project ID or project name
    * @param {number} skip
    * @param {number} top
    * @param {GitInterfaces.GitPushSearchCriteria} searchCriteria
    */
    QGitApi.prototype.getPushes = function (repositoryId, project, skip, top, searchCriteria) {
        var deferred = Q.defer();
        this.api.getPushes(repositoryId, project, skip, top, searchCriteria, function (err, statusCode, pushes) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(pushes);
            }
        });
        return deferred.promise;
    };
    /**
    * Queries the provided repository for its refs and returns them.
    *
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {string} project - Project ID or project name
    * @param {string} filter - [optional] A filter to apply to the refs.
    * @param {boolean} includeLinks - [optional] Specifies if referenceLinks should be included in the result. default is false.
    */
    QGitApi.prototype.getRefs = function (repositoryId, project, filter, includeLinks) {
        var deferred = Q.defer();
        this.api.getRefs(repositoryId, project, filter, includeLinks, function (err, statusCode, refs) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(refs);
            }
        });
        return deferred.promise;
    };
    /**
    * Creates or updates refs with the given information
    *
    * @param {GitInterfaces.GitRefUpdate[]} refUpdates - List of ref updates to attempt to perform
    * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
    * @param {string} project - Project ID or project name
    * @param {string} projectId - The id of the project.
    */
    QGitApi.prototype.updateRefs = function (refUpdates, repositoryId, project, projectId) {
        var deferred = Q.defer();
        this.api.updateRefs(refUpdates, repositoryId, project, projectId, function (err, statusCode, refs) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(refs);
            }
        });
        return deferred.promise;
    };
    /**
    * Create a git repository
    *
    * @param {GitInterfaces.GitRepository} gitRepositoryToCreate
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.createRepository = function (gitRepositoryToCreate, project) {
        var deferred = Q.defer();
        this.api.createRepository(gitRepositoryToCreate, project, function (err, statusCode, Repositorie) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Repositorie);
            }
        });
        return deferred.promise;
    };
    /**
    * Delete a git repository
    *
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.deleteRepository = function (repositoryId, project) {
        var deferred = Q.defer();
        this.api.deleteRepository(repositoryId, project, function (err, statusCode) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(null);
            }
        });
        return deferred.promise;
    };
    /**
    * Retrieve git repositories.
    *
    * @param {string} project - Project ID or project name
    * @param {boolean} includeLinks
    */
    QGitApi.prototype.getRepositories = function (project, includeLinks) {
        var deferred = Q.defer();
        this.api.getRepositories(project, includeLinks, function (err, statusCode, Repositories) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Repositories);
            }
        });
        return deferred.promise;
    };
    /**
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.getRepository = function (repositoryId, project) {
        var deferred = Q.defer();
        this.api.getRepository(repositoryId, project, function (err, statusCode, Repositorie) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Repositorie);
            }
        });
        return deferred.promise;
    };
    /**
    * Updates the Git repository with the single populated change in the specified repository information.
    *
    * @param {GitInterfaces.GitRepository} newRepositoryInfo
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.updateRepository = function (newRepositoryInfo, repositoryId, project) {
        var deferred = Q.defer();
        this.api.updateRepository(newRepositoryInfo, repositoryId, project, function (err, statusCode, Repositorie) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Repositorie);
            }
        });
        return deferred.promise;
    };
    /**
    * @param {GitInterfaces.GitStatus} gitCommitStatusToCreate
    * @param {string} commitId
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    */
    QGitApi.prototype.createCommitStatus = function (gitCommitStatusToCreate, commitId, repositoryId, project) {
        var deferred = Q.defer();
        this.api.createCommitStatus(gitCommitStatusToCreate, commitId, repositoryId, project, function (err, statusCode, Statuse) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Statuse);
            }
        });
        return deferred.promise;
    };
    /**
    * @param {string} commitId
    * @param {string} repositoryId
    * @param {string} project - Project ID or project name
    * @param {number} top
    * @param {number} skip
    */
    QGitApi.prototype.getStatuses = function (commitId, repositoryId, project, top, skip) {
        var deferred = Q.defer();
        this.api.getStatuses(commitId, repositoryId, project, top, skip, function (err, statusCode, Statuses) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Statuses);
            }
        });
        return deferred.promise;
    };
    /**
    * @param {string} repositoryId
    * @param {string} sha1
    * @param {string} project - Project ID or project name
    * @param {string} projectId
    * @param {boolean} recursive
    * @param {string} fileName
    */
    QGitApi.prototype.getTree = function (repositoryId, sha1, project, projectId, recursive, fileName) {
        var deferred = Q.defer();
        this.api.getTree(repositoryId, sha1, project, projectId, recursive, fileName, function (err, statusCode, Tree) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Tree);
            }
        });
        return deferred.promise;
    };
    /**
    * @param {string} repositoryId
    * @param {string} sha1
    * @param {string} project - Project ID or project name
    * @param {string} projectId
    * @param {boolean} recursive
    * @param {string} fileName
    */
    QGitApi.prototype.getTreeZip = function (repositoryId, sha1, project, projectId, recursive, fileName) {
        var deferred = Q.defer();
        this.api.getTreeZip(repositoryId, sha1, project, projectId, recursive, fileName, function (err, statusCode, Tree) {
            if (err) {
                err.statusCode = statusCode;
                deferred.reject(err);
            }
            else {
                deferred.resolve(Tree);
            }
        });
        return deferred.promise;
    };
    return QGitApi;
}(basem.QClientApiBase));
exports.QGitApi = QGitApi;
